#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>


int main()
{
	// 포인터
	// 데이터가 저장된 메모리의 위치값(주소값)을 저장하는 변수.

	int i = 50;

	int* p_i = &i;
	// 변수 생성시 자료형과 변수명 사이에 *을 붙이면 해당 변수는 주소값을 저장하는 변수가 된다.
	// 여기서 *은 곱하기의 의미가 아닌 포인터 변수를 만들겠다는 의미가 된다.

	printf("i : %d\n", i);
	printf("&i : %p\n", &i);
	printf("p_i : %p\n", p_i);
	// 생성한 데이터가 저장되는 주소값은 실행 할때마다 현재 비어있는 메모리 위치 중에서 프로그램이 자동적으로 선택하기 때문에
	// 실행할때마다 그 값이 바뀌고, 사용자가 임의의 주소값에 데이터를 넣을순 없다.

	// 변수 앞에 &기호를 붙이면 해당 변수가 저장된 주소값을 나타낸다.


	// 포인터의 역참조
	// 포인터는 데이터가 저장된 주소값을 저장하는 변수이기에 주소값을 알고 있다면 해당 주소값의 위치로 직접 찾아가서
	// 어떤 데이터가 저장되어있는지 확인할 수 있다.
	// 때문에 포인터를 통해 해당 주소에 저장된 값을 실제로 가져와서 사용하는 것이 가능하다.
	printf("*p_i : %d\n", *p_i);
	// 포인터의 역참조는 이미 생성된 포인터 변수 앞에 *을 붙이면 사용할수 있다.

	*p_i = 100;
	printf("i : %d\n", i);
	// 포인터의 역참조를 이용하면 주소값에 저장된 데이터를 사용할 수 있을 뿐 아니라 저장된 데이터를 직접 바꿀 수도 있다.
	// 포인터 p_i는 변수 i의 주소이기 때문에 p_i의 역참조값을 바꾸면 i의 값 역시 바뀐다.

	// 포인터 변수값을 scanf로 대입할수 있지만, 정상적인 주소가 아닐 가능성이 매우 높기때문에 사실상 사용하지 않는다.
	// p_i = 5000; // 5000은 숫자가 아닌 메모리 주소 5000을 의미.
	// printf("*p_i : %d\n", *p_i); (X)
	// 포인터 변수에 정수값을 대입하는 것도 가능은 하지만 위와 같은 이유로 해당 주소가 정상적인 주소가 아닐 가능성이 매우 높기때문에
	// 사용하려하면 에러가 발생한다.

	printf("10 + *p_i : %d\n", 10 + *p_i);
	// 포인터의 역참조는 해당 주소값에 저장된 데이터만 가져오기에 역참조를 통해 가져온 데이터로 연산, 대입 등이 가능하다.

	printf("*(&i) : %d\n", *(&i));
	// 변수 i의 주소값 &i의 역참조 *(&i) 같은 식으로도 사용은 가능하다.

	// i; 저장된 변수.
	// p_i; 변수가 저장된 주소값.
	// &i; 변수가 저장된 주소값.
	// *p_i; 저장된 변수.

	/*
		int형 변수를 만들어서 데이터를 입력하고
		int형 포인터변수를 생성해서 int형 변수의 주소를 저장하고,
		포인터를 이용해서 변수의 값을 바꾸고

		변수, 포인터변수, 변수의 주소, 포인터변수의 역참조를 출력해보자.	
	*/

	printf("\n");

	int i2 = 10;
	int* p_i2 = &i2;
	*p_i2 = 20;
	
	printf("i2 : %d\n",i2);
	printf("p_i2 : %p\n", p_i2);
	printf("&i2 : %p\n", &i2);
	printf("*p_i2 : %d\n", *p_i2);
	
	char c = 'a';
	char* p_c = &c;

	return 0;
}