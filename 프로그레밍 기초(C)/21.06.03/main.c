#define	_CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>

int main()
{
	//// 배열 p.208
	//// 변수를 생성할때는 한번에 하나씩 생성하고
	//// 생성된 변수마다 각각 다른 변수명을 만들어줘야하는 번거로움이 있다.
	//// 때문에 동일한 목적을 가진 변수를 다수 만들려 할 경우 많은 작업량과 코드가 필요해진다.
	//// 이러한 문제를 해결하기위해 나온 방법이 배열이라는 개념.

	//int ary[5];
	//// 배열생성방법 : 자료형 변수명[만들 변수의 갯수]

	//ary[0] = 1;
	//ary[1] = 2;
	//ary[2] = 3;
	//ary[3] = 4;
	//ary[4] = 5;
	//// 생성된 배열 변수는 동일한 이름을 가진 변수이며 다만, 서로 다른 번호(index)를 가지기 때문에
	//// 이 번호를 변수명 뒤에 붙여서 변수에 접근한다.
	//// 사용하는 번호는 0부터 시작하며 배열의 갯수 -1번까지 사용가능하다.

	//ary[2] = ary[1] + ary[2];
	//ary[2] > ary[1];

	//printf("%d\n", ary[4]);
	//// 그 외의 부분은 통상적인 변수와 완전히 동일하다.
	//// 서로 사칙연산이나, 관계연산자를 통한 비교도 가능하며 데이터들간의 대입, 다른 코드에 사용하는 것도 가능.

	//// 배열값의 번호(index)는 무조건 0부터 시작하며 정수만 사용할 수 있다.
	//// 단, 결과가 정수기만 하면 되기 때문에 수식을 적는 것은 가능하다.
	//printf("%d\n", ary[10 % 3]);
	//// 해당코드는 ary[1]의 데이터를 출력하는 코드.

	///*
	//	float형 변수를 저장하는 10개짜리 배열을 만들고 임의의 숫자로 배열을 초기화 한 뒤에
	//	배열 0번부터 9번까지의 데이터를 출력해보자.
	//*/

	//float f_ary[10] = { 1.f, 2.f, 3.f, 4.f, 5.f };
	//// 배열의 선언과 동시에 초기화를 할 수 있다.
	//// 배열의 각 index번째에 넣어둘 데이터를 중괄호 안에 순서대로 넣어주면된다.
	//// 이러한 초기화는 배열을 선언(생성)할때만 사용할수 있다.
	//// 초기화에서 빠뜨린 배열번호의 데이터는 자동으로 기본값으로 초기화 해준다.
	//// 숫자 -> 0, 문자 -> 빈문자
	//// 중간의 데이터를 빼먹을 수 없고, 작성하지 않은 이후의 모든 데이터를 뺄수만 있다.

	//f_ary[0] = 1.1f;
	//f_ary[1] = 2.1f;
	//f_ary[2] = 3.1f;
	//f_ary[3] = 4.1f;
	//f_ary[4] = 5.1f;
	//// 배열에 들어가야하는 데이터가 서로 아무런 연관도 연속성도 없는 경우에는 위처럼 직접 데이터를 입력한다.

	//for (int i = 0; i < 10; i++)
	//{
	//	f_ary[i] = i + 1.f;
	//}
	//// 반복문을 사용하면 배열 내의 데이터에 쉽게 접근할수있다.

	//printf("\n");

	//for (int i = 0; i < 10; i++)
	//{
	//	printf("f_ary[%d] = %.1f\n", i, f_ary[i]);
	//}

	//printf("\n");

	//for (int i = 0; i < 10; i++)
	//{
	//	scanf(" %f", &f_ary[i]);
	//}
	//for (int i = 0; i < 10; i++)
	//{
	//	printf("f_ary[%d] = %.1f\n", i, f_ary[i]);
	//}
	//// 배열은 단순히 여러개의 변수를 만드는 것 뿐 아니라 접근하기 용이한 변수를 만드는 의미이기도 하다.
	//// scanf, printf가 일반적인 변수를 10개에 접근하려 했다면 scanf, printf를 각각 10줄씩 작성해야겠지만.
	//// 배열은 같은 이름의 인덱스 번호만 다른 변수이기 때문에 반복문을 통해 쉽게 여러 데이터에 접근할 수 있다.

	/*
		정수를 저장하는 10개짜리 배열을 만들고 임의의 숫자로 초기화 한 뒤에
		사용자에게 숫자를 입력받아서 해당숫자가 배열 내에 존재하는지 유무를 출력해주는 코드를 작성해보자.
	*/

	//int i_ary[10];
	//int input;

	//for (int i = 0; i < 10; i++)
	//{
	//	i_ary[i] = i + 1;
	//}

	//scanf(" %d", &input);

	//for (int i = 0; i < 10; i++)
	//{
	//	if (i_ary[i] == input)
	//	{
	//		printf("입력하신 숫자 %d는 i_ary[%d]에 있습니다.", input, i);
	//		break;
	//		// "반복문" 내에 break가 존재한다면 반복문을 탈출함.
	//	}
	//	else if (input != i_ary[i] && i == 9)
	//	{
	//		printf("입력하신 숫자 %d는 i_ary배열에 없습니다.", input);
	//	}
	//}
	///*
	//int result = 0;

	//for (int i = 0; i < 10; i++)
	//{
	//	if (i_ary[i] == input)
	//	{
	//		result = 1;
	//	}
	//}

	//if (result == 1)
	//{
	//	printf("입력하신 숫자 %d는 i_ary배열에 있습니다.", input);
	//	break;
	//}
	//else
	//{
	//	printf("입력하신 숫자 %d는 i_ary배열에 없습니다.", input);
	//}
	//*/

	//int ii = 0;
	//int i2 = 0;
	//while (ii < 10)
	//{
	//	ii++;
	//	if (ii % 2 == 0)
	//	{
	//		continue;
	//	}
	//	i2 += ii;
	//}
	//// 반복문 내에 continue가 존재하는 경우
	//// continue 아래에 있는 코드를 실행하지 않고 
	//// 다음 반복횟수로 넘어가게된다.

	//char str[50] = {'a','b','c'};
	//char str2[50] = "abc";
	//// 문자열 : 여러개의 문자를 저장하는 변수들을 배열로 만들어 문장을 저장하도록 만든 배열을 뜻함.
	//// 일반 배열처럼 문자 하나하나씩 중괄호에 넣어서 초기화할수도 있지만
	//// 문장을 통째로 큰따옴표를 통해 초기화하는것도 가능하다.
	//
	//scanf(" %s", &str);
	//scanf(" %c", &str2[3]);
	//// 문장을 입력받을때는 %s를 서식문자로 사용하며 변수 뒤에는 배열명을 그대로 적는다.
	//// 배열뒤에 인덱스(번호)를 포함하면 문자열이 아닌, 문자 한글자를 입력받는 의미이기 때문에 %s가 아닌 %c로 받아야 한다.

	//printf("문자열 출력\n");
	//printf("%s\n", str);
	//printf("%c\n", str2[3]);
	//// 문자열 전체를 출력하고자 한다면 %c가 아닌 %s를 사용하며
	//// 변수부분에는 배열의 이름을 번호없이 그대로 입력한다.
	//// 배열이름에 번호를 붙이면 문자열 안에 있는 문자 '하나'를 의미하기때문에 
	//// %s로는 제대로 출력할수 없다.

	//char _str[5] = "abcd";
	//// 문자열은 다른 배열과는 다른 특징이 하나 있는데
	//printf("\n%s\n", _str);
	//// 문자열은 배열을 만들때 지정한 갯수보다 하나 적은 수의 문자를 저장할수 있다.
	//// ex) _str은 5개의 문자를 저장하는 문자열 이지만 실제로는 4개의 문자만을 저장할수 있다.
	//// 5개 저장시에는 출력이 이상하게 된다.

	//// 문자열의 경우 문장의 마지막이 어디인지 별도로 표시를 해줘야 정상적인 사용이 가능하다.
	//// 따라서 문자열의 저장공간에는 적어도 하나의 여유공간이 있어야 
	//// 해당 공간에 문장이 여기서 끝임을 알리는 끝맺음 문자(NULL문자)를 넣을수 있다.
	///* _str을 예시로 들자면
	//_str[0]='a'
	//_str[1]='b'
	//_str[2]='c'
	//_str[3]='d'
	//_str[4]='\0'
	//위처럼 마지막 배열에는 더 이상 뒤에 다른 문자가 없음을 나타내는 널문자(\0)이 들어간다. 
	//*/

	//char myStr[256] = "qwert";
	///*
	//myStr[0]='q'
	//myStr[1]='w'
	//myStr[2]='e'
	//myStr[3]='r'
	//myStr[4]='t'
	//myStr[5]='\0'
	//널문자는 반드시 해당 배열의 가장 마지막에 들어가는 건 아니다.
	//위처럼 배열크기보다 적은 문장을 입력했을 때는 배열 중간에도 들어갈 수 있다.
	//5번 이후의 배열에는 모두 널문자로 초기화된다.

	//만약 문장 끝에 널문자가 존재하지 않으면
	//해당 배열에 저장된 문장이 어디서 끝나는지 모르기때문에
	//배열을 출력한다면, 배열의 모든 데이터를 출력하려 시도할 것이기 때문에 255번까지, 불필요하게 많은 데이터를 출력하게 된다.
	//따라서 이러한 낭비를 막기 위해 문장 끝에는 반드시 널문자가 들어가야하며, 이 때문에 실제 저장 가능한 문자의 갯수는
	//저장공간의 갯수 -1개가 된다.
	//*/
	//
	//char _chr[256] = "zxcvb";
	//_chr[6] = 'p';
	//// [z][x][c][v][b][\0][p].....
	//printf("\n\n%s", _chr);
	//char _chr2[256] = "qwerasdfzxcv";
	//_chr2[5] = '\0';
	//printf("\n\n%s", _chr2);

	//// 문자열이 초기화 된 후에 널문자 뒤에 따로 문자를 추가로 넣더라도
	//// 널문자가 존재하는 시점에서 다른 뒤의 문자는 출력되지 않으며
	//// 반대로 정상적인 문장 중간에 직접 널문자를 넣으면
	//// 마찬가지로 널문자가 입력된 곳에서 출력이 종료된다.
	//
	//char korean[10] = "양명균";
	//printf("\n\n%s", korean);

	//for (int i = 0; i < 10; i++)
	//{
	//	printf("\n%c", korean[i]);
	//}
	// 한글이나 일본어와 같은 특수문자취급을 받는 문자의 경우, 배열에서 2칸을 차지해서 하나의 문자를저장한다.
	// 때문에 printf로 배열에 저장된 문자 하나를 출력하면 정상적으로 출력이 되지 않는다.
	// 이러한 문자는 배열의 크기/2-1개의 문자를 저장할수 있다.(문자 크기가2, 널문자공간 1개)

	/*
		1. 본인의 이름을 입력받아서
		이름 : 입력한이름
		처럼 출력되도록 해보자.

		2. 영단어를 입력해서 반대로 출력되게 해보자.
		-> printf를 5,4,3,2,1로 출력하는 방식
		-> 배열에 저장된 문자 자체를 뒤집는 방식
		ex)char c[256]->abcde
			c->[a][b][c][d][e]->[e][d]][c][b][a]

		3. 영단어를 입력하고 해당 단어에 모음이 몇개 들어가는지 출력하자.
		(a,e,i,o,u)
	*/

	printf("1)\n");

	char name[64];

	scanf(" %s", &name);
	printf("\n%s\n", name);

	printf("\n");

	//----------------------------------------------------------------

	printf("2)\n");

	printf("방식 1\n\n");

	printf("배열을 역순으로 출력하는 방식.\n");
	char str[64];

	printf("영단어를 입력하세요\n");
	scanf(" %s", &str);

	for (int i = 4; i >= 0; i--)
		printf("%c", str[i]);

	printf("\n");

	printf("역순으로 다른 배열에 옴겨서 출력하는 방식.\n");

	char reversestr[64];

	for (int i = 0; i < 5; i++)
		reversestr[i] = str[4 - i];

	reversestr[5] = '\0';

	printf("reversestr : %s\n", reversestr);
	// 글자를 한글자씩 대입 했기 때문에 따로 대입하지 않은 마지막 널문자의 위치에는
	// 정상적인 글자가 아닌 쓰레기 데이터가 들어가 있다.
	// 따라서 직접 널문자를 따로 넣어주거나 혹은, 배열을 만들때 빈문장으로 초기화를 해주면
	// 배열 전체가 널문자로 초기화가 된다.

	printf("\n");
	
	printf("원본 배열에 저장된 문자 자체를 뒤집는 방식.\n");

	char tmp[64];
	strcpy(tmp, str);

	for (int i = 0; i < 5 / 2; i++)
	{
		str[i] = str[4 - i];
		str[4 - i] = tmp[i];
	}
	printf("str : %s\n", str);

	printf("\n");

	//----------------------------------------------------------------

	printf("3)\n");

	char eng[64];
	printf("영단어를 입력해 주세요.\n");
	scanf(" %s", &eng);

	int many = 0;
	for (int i = 0; eng[i] != '\0'; i++)
	{
		if ((eng[i] == 'a') || (eng[i] == 'e') || (eng[i] == 'i') || (eng[i] == 'o') || (eng[i] == 'u'))
			many++;
		else
			continue;
	}

	printf("입력하신 영단어 %s에서 모음은 %d개 있습니다.", eng, many);

	printf("\n");

	// 문자열의 대입
	// 문자열은 기본적으로 배열을 생성할때만 문자열 전체를 한번에 대입 할 수 있으며
	// 이후에는 한글자씩을 바꾸거나 scanf를 통해 입력 받는 것만 가능하다.
	// 때문에 외부의 입력이 아닌, 프로그램 내부에서 문자열을 재차 대입하기 위해서는 별도의 방법이 필요하다.

	// str = "qwer"; (X)
	// 위처럼 문자열에 문장을 대입연산자를 통해서 대입할수 없다.

	strcpy(str, "XYZ"); // str = "XYZ"와 동일한 의미
	// string copy의 약자.

	char str2[5] = "abc";
	char str3[5] = "qwe";

	// str2 = str3;
	// 문자열은 생성할 때 대입은 가능하지만 그 이후에는 변수들 끼리라고 할지라도 대입이 안된다.

	//======================================================
	// 다차원배열

	int multiAry[5][5] = { {1,2,3,4,5}, {6,7,8,9,10}, {11,12,13,14,15}, {16,17,18,19,20}, {21,22,23,24,25} };
	// 5개의 방을 가진 5층짜리 건물.
	// 배열을 중첩해서 배열 안에 배열을 만든다.
	// 배열 안에 배열이 있는 것이기 때문에 초기화 할때는 중괄호 안에 중괄호를 넣어서 각 배열을 따로 초기화 해준다.
	// 다차원배열이라는 이름에서 알수 있다시피 2중, 3중 몇중으로든 배열을 중첩할수 있지만,
	// 그 구조가 이해하기 난해해지기 때문에 통상적으로 2차원배열정도까지를 많이 쓴다.

	multiAry[0][3] = 10;
	// 일반 배열과 마찬가지로 배열의 index를 넣어서 해당 번호에 존제하는 데이터로 접근할수 있다.
		
	return 0;
}